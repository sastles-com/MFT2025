#include <M5Unified.h>
#include <LittleFS.h>
#include <PSRamFS.h>
#include <Preferences.h>
#include <driver/spi_common.h>

namespace {
constexpr const char *kImageRoot = "/images";
constexpr size_t kCopyBufferSize = 2048;

#ifdef DEBUG
void logDirectory(fs::FS &fs, const char *path, uint_fast8_t depth = 0) {
  File dir = fs.open(path);
  if (!dir || !dir.isDirectory()) {
    Serial.printf("[Debug] %s is not a directory\n", path);
    if (dir) {
      dir.close();
    }
    return;
  }

  Serial.printf("[Debug] Listing %s\n", path);
  File entry = dir.openNextFile();
  while (entry) {
    for (uint_fast8_t i = 0; i < depth; ++i) {
      Serial.print(' ');
      Serial.print(' ');
    }
    Serial.printf("%s%s\n", entry.name(), entry.isDirectory() ? "/" : "");
    if (entry.isDirectory()) {
      logDirectory(fs, entry.name(), depth + 1);
    }
    entry = dir.openNextFile();
  }
  dir.close();
}
#endif

bool copyFile(fs::FS &src, fs::FS &dst, const char *srcPath, const char *dstPath) {
  File in = src.open(srcPath, FILE_READ);
  if (!in) {
    Serial.printf("[LittleFS] failed to open %s for read\n", srcPath);
    return false;
  }
  File out = dst.open(dstPath, FILE_WRITE);
  if (!out) {
    Serial.printf("[PSRamFS] failed to open %s for write\n", dstPath);
    in.close();
    return false;
  }

  uint8_t buffer[kCopyBufferSize];
  while (in.available()) {
    size_t read = in.read(buffer, sizeof(buffer));
    if (!read) {
      break;
    }
    size_t written = out.write(buffer, read);
    if (written != read) {
      Serial.printf("[PSRamFS] short write on %s\n", dstPath);
      in.close();
      out.close();
      return false;
    }
  }

  in.close();
  out.close();
  return true;
}

bool mirrorDirectory(fs::FS &src, fs::FS &dst, const char *path) {
  File dir = src.open(path);
  if (!dir || !dir.isDirectory()) {
    Serial.printf("[LittleFS] directory %s not found\n", path);
    return false;
  }

  if (!dst.exists(path)) {
    if (!dst.mkdir(path)) {
      Serial.printf("[PSRamFS] failed to mkdir %s\n", path);
      dir.close();
      return false;
    }
  }

  File entry = dir.openNextFile();
  while (entry) {
    String entryName = entry.name();
    if (entry.isDirectory()) {
      if (!mirrorDirectory(src, dst, entryName.c_str())) {
        entry.close();
        dir.close();
        return false;
      }
    } else {
      if (!copyFile(src, dst, entryName.c_str(), entryName.c_str())) {
        entry.close();
        dir.close();
        return false;
      }
    }
    entry = dir.openNextFile();
  }

  dir.close();
  return true;
}

bool mountFileSystems() {
  if (!LittleFS.begin(false)) {
    Serial.println("[LittleFS] mount failed, formatting...");
    if (!LittleFS.begin(true)) {
      Serial.println("[LittleFS] mount failed after format");
      return false;
    }
  }

  if (!PSRamFS.begin()) {
    Serial.println("[PSRamFS] mount failed");
    return false;
  }

  return true;
}

bool stageAssets() {
  if (!LittleFS.exists(kImageRoot)) {
    Serial.println("[LittleFS] no image assets to mirror");
    return true;
  }
  return mirrorDirectory(LittleFS, PSRamFS, kImageRoot);
}
}

void setup() {
  //  auto cfg = M5.config();
  //  M5.begin(cfg);

  //  const char* name;
  //  switch (M5.getBoard()) {
  //      case m5::board_t::board_M5StackCoreS3:  name = "StackS3";     break;
  //      case m5::board_t::board_M5AtomS3Lite:   name = "ATOMS3Lite";  break;
  //      case m5::board_t::board_M5AtomS3:       name = "ATOMS3";      break;
  //      case m5::board_t::board_M5StampC3:      name = "StampC3";     break;
  //      case m5::board_t::board_M5StampS3:      name = "StampS3";     break;
  //      case m5::board_t::board_M5StampC3U:     name = "StampC3U";    break;
  //      case m5::board_t::board_M5Stack:        name = "Stack";       break;
  //      case m5::board_t::board_M5StackCore2:   name = "StackCore2";  break;
  //      case m5::board_t::board_M5StickC:       name = "StickC";      break;
  //      case m5::board_t::board_M5StickCPlus:   name = "StickCPlus";  break;
  //      case m5::board_t::board_M5StackCoreInk: name = "CoreInk";     break;
  //      case m5::board_t::board_M5Paper:        name = "Paper";       break;
  //      case m5::board_t::board_M5Tough:        name = "Tough";       break;
  //      case m5::board_t::board_M5Station:      name = "Station";     break;
  //      case m5::board_t::board_M5Atom:         name = "ATOM";        break;
  //      case m5::board_t::board_M5AtomS3R:     name = "ATOM S3R";    break;
  //      case m5::board_t::board_M5AtomPsram:    name = "ATOM PSRAM";  break;
  //      case m5::board_t::board_M5AtomU:        name = "ATOM U";      break;
  //      case m5::board_t::board_M5TimerCam:     name = "TimerCamera"; break;
  //      case m5::board_t::board_M5StampPico:    name = "StampPico";   break;
  //      default:                                name = "Who am I ?";  break;
  //  }
  //  Serial.println(name);




  Preferences prefs;
  if (prefs.begin("M5GFX", false)) {
    prefs.putUInt("AUTODETECT",
                  static_cast<uint32_t>(m5gfx::board_t::board_M5AtomS3R));
    prefs.end();
  }

  {
    auto disp_cfg = M5.Display.config();
    disp_cfg.bus_config.spi_host = SPI3_HOST;
    M5.Display.config(disp_cfg);
  }

  auto cfg = M5.config();
  cfg.fallback_board = m5::board_t::board_M5AtomS3R;
  M5.begin(cfg);

  Serial.begin(115200);
  Serial.println();
  Serial.println("Isolation Sphere booting...");

  if (!mountFileSystems()) {
    M5.Log.println("Filesystem init failed");
    while (true) {
      delay(1000);
      M5.Log.println("-- Filesystem init failed");
    }
  }

  if (!stageAssets()) {
    M5.Log.println("Asset staging failed");
  }

#ifdef DEBUG
  if (PSRamFS.exists(kImageRoot)) {
    logDirectory(PSRamFS, kImageRoot);
  } else {
    Serial.printf("[Debug] %s not found in PSRamFS\n", kImageRoot);
  }
#endif

  M5.Log.println("LittleFS and PSRamFS ready");
}

void loop() {
  M5.update();
  delay(16);
}
