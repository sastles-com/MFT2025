# 🎯 LED球体統合レンダリングアーキテクチャ設計

## 参考文献
- **姿勢制御機能付き球体Lチカを作ろう①** - https://tajmahal0707.hatenablog.com/entry/2023/06/08/074346
  - IMU quaternion による球面座標変換アルゴリズム
  - ESP32における arctan2/sqrt 高速近似計算手法
  - 球面上の点 pos を quaternion 回転後の UV座標マッピング式：
    - `pos' = quat.rotateVector(pos)`
    - `u = arctan2(√(rx²+rz²), ry)`
    - `v = arctan2(rx, rz)`
  - パフォーマンス検証結果：
    - `atan2`: 2.09μs/回 → 近似計算: 0.00001μs/回 (約20万倍高速化)
    - `sqrt`: 15μs/回 → 近似計算: 4.4μs/回 (約3.4倍高速化)


## 📋 要件分析

### 現状の課題
- **画像系**: 10fps想定、全800LED計算必須、高品質だが重い処理
- **ProceduralPatternGenerator**: 30fps想定、色付きLEDのみ計算、軽量だが機能限定
- **共通出力**: 両方とも800個のLEDのRGB配列→FastLED送信

### 設計目標
- **統一インターフェース**: 画像とプロシージャルの後半処理共用
- **パフォーマンス最適化**: 用途別の最適化戦略
- **フレームレート**: プロシージャル30fps、画像10fpsの両立

---

## 🏗️ アーキテクチャ設計

### 1. 統合レンダリングシステム

```cpp
namespace LEDSphere {
    class LEDSphereRenderer {
        // 統一出力インターフェース
        - CRGB leds_[800]              // FastLED出力バッファ
        - std::vector<LEDPosition>     // led_layout.csv読み込み
        - UV座標キャッシュシステム      // 姿勢変換結果キャッシュ
        
        // 描画方式選択
        void render(RenderParams)
        ├─ PROCEDURAL_PATTERN → スパースレンダリング（30fps）
        ├─ IMAGE_TEXTURE → フルレンダリング（10fps）
        └─ HYBRID → 画像＋プロシージャル合成
    }
}
```

### 2. パフォーマンス最適化戦略

#### 📈 プロシージャルパターン（30fps高速化）
- **スパースレンダリング**: 必要なLEDのみ計算
- **座標軸インジケータ**: 3点（X,Y,Z）のみ → 800点計算不要
- **緯度線光の輪**: 1本の輪（~36点）のみ → 全球計算不要
- **UV座標キャッシュ**: 姿勢変化時のみ更新

```cpp
class FastPatternRenderer {
    void renderCoordinateAxis()   // 3LED のみ点灯
    void renderLatitudeRing()     // 36LED 程度のみ点灯
    void renderSparsePattern()    // アクティブLEDのみ計算
}
```

#### 🖼️ 画像テクスチャ（10fps高品質）
- **フルレンダリング**: 全800LED計算（品質重視）
- **バイリニア補間**: 高品質テクスチャサンプリング
- **画像キャッシュ**: JPEG→RGB変換結果をキャッシュ

```cpp
class ImageTextureRenderer {
    void renderFullTexture()      // 全800LED計算
    CRGB sampleTexture(u, v)      // バイリニア補間
    bool loadImageToCache()       // JPEG→RGB変換
}
```

### 3. 共通後半処理の統一

#### 座標変換パイプライン（両方式共通）
```cpp
LED物理位置(x,y,z) 
    ↓ IMU姿勢変換（quaternion + offset）
変換後位置(x',y',z')
    ↓ 球面座標変換
UV座標(u,v) [0.0-1.0]
    ↓ 描画方式選択
LEDカラー値 → FastLED出力
```

#### UV座標キャッシュシステム
- **姿勢変化検出**: quaternion/offset差分監視
- **キャッシュ更新**: 変化時のみ全LED再計算
- **高速参照**: 変化なしなら既存UV座標使用

---

## ⚡ パフォーマンス比較

### プロシージャルパターン（30fps）
| パターン | アクティブLED | 計算量 | 期待fps |
|----------|---------------|--------|---------|
| 座標軸インジケータ | 3-15個 | ~1.9% | 30fps✅ |
| 緯度線光の輪 | 36-72個 | ~9% | 30fps✅ |
| 経度線波動 | 144個 | ~18% | 25-30fps |
| 全プロシージャル | 200-400個 | ~50% | 15-20fps |

### 画像テクスチャ（10fps）
| 処理 | 計算量 | 期待fps |
|------|--------|---------|
| JPEG デコード | 重い | 1回のみ |
| UV→RGB サンプリング | 800回 | 10fps✅ |
| バイリニア補間 | 高品質 | 8-12fps |

### ハイブリッド（座標軸＋画像）
- **画像**: 全800LED（10fps）
- **座標軸**: 3LED追加（オーバーレイ）
- **合計**: 10fps（画像がボトルネック）

---

## 🔧 実装方針

### 方針A: 統合アーキテクチャ【推奨】
- **LEDSphereRenderer**: 統一インターフェース
- **FastPatternRenderer**: プロシージャル特化クラス
- **ImageTextureRenderer**: 画像特化クラス
- **共通後半処理**: UV変換、FastLED出力

**メリット**:
✅ コード重複なし  
✅ パフォーマンス最適化  
✅ 拡張性・保守性  
✅ デバッグの容易さ  

**デメリット**:
⚠️ 初期実装コスト  
⚠️ クラス設計の複雑さ  

### 方針B: 分離アーキテクチャ
- **ProceduralPatternSystem**: 独立システム（30fps）
- **ImageTextureSystem**: 独立システム（10fps）
- **重複実装**: UV変換、FastLED出力を各々実装

**メリット**:
✅ シンプルな実装  
✅ 独立した最適化  

**デメリット**:
❌ コード重複  
❌ 保守コストx2  
❌ 機能追加時の影響範囲  

---

## 📊 パフォーマンス目標

### 目標フレームレート
- **座標軸インジケータ**: 30fps（デバッグ用）
- **プロシージャルパターン**: 20-30fps（リアルタイム演出）
- **画像テクスチャ**: 10fps（高品質表示）
- **ハイブリッド**: 10fps（画像＋オーバーレイ）

### メモリ使用量
- **LED バッファ**: 800 × 3byte = 2.4KB
- **UV キャッシュ**: 800 × 8byte = 6.4KB  
- **画像キャッシュ**: 128×128×3 = 48KB
- **合計**: ~57KB（PSRAM使用で問題なし）

### CPU使用率目標
- **Core0**: 通信・制御処理（50%以下）
- **Core1**: LEDレンダリング（70%以下）
- **30fps時**: 33ms/frame以内での完了

---

## 🚀 実装優先順位

### Phase 1: 基礎システム
1. **LEDSphereRenderer**: 基本クラス実装
2. **LED配置読み込み**: led_layout.csv解析
3. **UV座標変換**: 球面座標システム
4. **FastLED統合**: 4ストリップ出力

### Phase 2: プロシージャル高速化
1. **座標軸インジケータ**: スパースレンダリング実装
2. **緯度線光の輪**: 部分描画最適化
3. **パフォーマンス測定**: フレームレート監視

### Phase 3: 画像統合
1. **ImageTextureRenderer**: 全LED描画
2. **JPEG デコード統合**: TJpg_Decoder連携
3. **バイリニア補間**: 高品質サンプリング

### Phase 4: 最適化・統合
1. **ハイブリッドモード**: 画像＋プロシージャル
2. **パフォーマンス最適化**: プロファイリング
3. **統計・デバッグ機能**: フレームレート監視

---

## 💡 結論

**推奨アーキテクチャ**: 統合システム（方針A）

**理由**:
1. **パフォーマンス目標達成**: プロシージャル30fps、画像10fps両立
2. **保守性**: 統一インターフェースによるコード品質向上
3. **拡張性**: 新パターン・機能追加の容易さ
4. **デバッグ効率**: 統一されたデバッグ・統計システム

LED球体という特殊なハードウェアにおいて、用途別最適化と共通処理の統一により、両方の要件を満たす設計が実現可能です🎯