# MQTTを用いた画像転送の包括的ガイド：ESP32での実装とトピック設計

## 1. ESP32とMQTTでの画像転送の概要

本ガイドでは、MQTTの軽量でイベント駆動型の特性を活かし、ESP32上で画像を効率的に転送する方法を解説します。2KBから30KB程度の小さなJPEG画像であれば、単一のMQTTメッセージとして分割せずに送信することが可能です。

---

## 2. 転送のための前提と推奨設定

- **ESP32とPSRAM**: 画像データは大量のメモリを消費するため、**PSRAM（Pseudo-Static RAM）を有効にする**ことを強く推奨します。これにより、システムの安定性が向上し、より大きなメッセージバッファを確保できます。
- **MQTTブローカー**: ESP32をブローカーとして運用する場合、メッセージバッファサイズを転送する**画像の最大サイズに合わせて設定**します。例えば、最大30KBの画像であれば、35KB程度のバッファを設定することで、メモリの効率的な利用と安定した通信を両立させます。
- **画像形式**: 圧縮効率の高い**JPEG形式**を使用します。

---

## 3. 画像転送のワークフロー

1. **画像データの準備**:
    - カメラモジュールで画像をキャプチャします。
    - キャプチャしたデータをJPEG形式に圧縮し、ファイルサイズを削減します。
2. **MQTTによる転送**:
    - 圧縮したJPEG画像をバイナリデータ（バイト列）に変換します。
    - このバイト列をMQTTメッセージのペイロードに格納し、特定のトピック（例: `sphere/images/frame`）にパブリッシュします。
    - **QoS (Quality of Service)**: 確実にメッセージを届けたい場合は`QoS 1`や`QoS 2`を、リアルタイム性を優先する場合は`QoS 0`を選択します。
    - **Retained Message**: UIなどが常に最新の画像を表示する必要がある場合、`retain`フラグを`true`に設定し、ブローカーに最新画像のみを保持させます。
3. **受信側の処理**:
    - 画像データがパブリッシュされるトピックを購読します。
    - メッセージを受信したらペイロードからバイト列を取り出します。
    - 取得したバイト列をJPEG画像に復元し、表示または保存します。

---

## 4. パフォーマンス最適化とトピック設計

### 4.1. パフォーマンス最適化技術

- **DMA (Direct Memory Access)**: CPUを介さずにメモリからWi-Fiバッファへデータを直接転送することで、CPUの負荷を軽減し、転送速度を向上させます。
- **ダブルバッファ**: 送信側で2つのバッファを用意し、一方のバッファで画像を送信中に、もう一方で次の画像を準備することで、連続的な画像転送をスムーズにします。
- **イベント駆動型**: ポーリングは非効率なため推奨しません。データ更新時にのみメッセージを送信することで、ネットワーク帯域幅と電力消費を最小限に抑えます。

### 4.2. MQTTトピック設計のベストプラクティス

- **全体の接頭語（プレフィックス）**:
    - トピック名の先頭にシステム全体を示すプレフィックス（例: `sphere`）を使用し、トピックの衝突を防ぎ、管理を容易にします。
    - 例: `sphere/ui/display/status`
- **UIコマンドの設計**:
    - 単純なON/OFFのような状態変化は、**個別のトピック**（例: `sphere/ui/display/enable`）として発行します。
    - 複数の設定値をまとめて送信する場合は、一つのトピックに**JSON形式のペイロード**を含めて発行します。
- **ワイルドカードの活用**:
    - `sphere/ui/display/enable`と`sphere/ui/audio/enable`のように、複数のトピックをまとめて購読したい場合は、**マルチレベルワイルドカード `#`**（例: `sphere/ui/#`）を使用することで、UI関連のすべてのメッセージを一括で受信できます。